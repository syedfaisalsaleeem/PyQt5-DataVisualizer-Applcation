# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'load_data.ui'
#
# Created by: PyQt5 UI code generator 5.15.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from helper import guess_data_types,clean_headers,enforce_data_types
from change_type import Ui_TypeWindow
import pandas as pd
from helper import show_error_message,show_success_message,engine
import sqlite3
from dateutil.parser import parse


class Ui_Select(object):
    
    def __init__(self,data=None,dropdown=None,db_function=None):
        super().__init__()
        # get the dropdown menu from the previous window
        self.comboBox = dropdown
        # get the function from the previous window
        self.db_function = db_function
        # clean the data helder from the function imported from data
        self.data = clean_headers(data)
        # get the data columns in string format
        self.data_columns = [str(d) for d in self.data.columns.values]
        # create a list of the data types that a dataframe has
        self.guess_types = guess_data_types(self.data)
        #creataa dictionary with data types
        self.meta_data = self.process_meta_data()

    def setupUi(self, Select):
        # set object name of the  main window which is names as select
        Select.setObjectName("Select")
        # resize the window 
        Select.resize(751, 541)
        # set the central widget in main window
        self.centralwidget = QtWidgets.QWidget(Select)
        # set the object name
        self.centralwidget.setObjectName("centralwidget")
        # create a qtable widget 
        # self.tableWidget = QtWidgets.QTableWidget(self.centralwidget)
        # set the position of widget
        # self.tableWidget.setGeometry(QtCore.QRect(10, 70, 731, 192))
        # set the obejct name of the tablewidget
        # self.tableWidget.setObjectName("tableWidget")
        # intitliaze the column count
        # self.tableWidget.setColumnCount(0)
        # intitliizie the row count
        # self.tableWidget.setRowCount(0)
        # add a text field
        self.plainTextEdit = QtWidgets.QPlainTextEdit(self.centralwidget)
        self.plainTextEdit.setGeometry(QtCore.QRect(10, 320, 171, 31))
        self.plainTextEdit.setObjectName("plainTextEdit")
        # add alabel widgetr
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(10, 300, 131, 16))
        self.label.setObjectName("label")
        # add a pusgh button
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(320, 430, 111, 41))
        self.pushButton.setObjectName("pushButton")
        self.pushButton.clicked.connect(lambda:self.save_dataset(Select))
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(10, 30, 151, 21))
        font = QtGui.QFont()
        font.setPointSize(20)
        self.label_2.setFont(font)
        self.label_2.setObjectName("label_2")
        Select.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(Select)
        self.statusbar.setObjectName("statusbar")
        Select.setStatusBar(self.statusbar)
        self.retranslateUi(Select)
        QtCore.QMetaObject.connectSlotsByName(Select)
        # self.tableWidget.horizontalHeader().sectionClicked.connect(self.clicked_column)

    def clicked_column(self,logical_index):
        '''
            This function open the  datattype dialigue to change the datatype
        '''
        # get the columns name of the data
        column_name = self.data_columns
        print(column_name[logical_index])
        # geet the cslected the column
        current = self.guess_types[column_name[logical_index]]
        print(current['datatype'])
        # passs it into change data type window
        self.Select = QtWidgets.QMainWindow()
        self.ui = Ui_TypeWindow(current['datatype'],column_name[logical_index],self.meta_data)
        self.ui.setupUi(self.Select)
        self.ui.set_dropdown_options()
        self.Select.show()

    def process_meta_data(self):
        '''
            create a dict with the guessed data columns
        '''
        meta_data ={}
        for column in self.data_columns:
            meta_data[column] = {}
            meta_data[column]['datatype'] = self.guess_types[column]['datatype']
        return meta_data

    def save_dataset(self,main_window):
        '''
            This function saves the dataset in the database
        '''
        #get the database name form text field
        db_name = self.plainTextEdit.toPlainText().replace('\n','')
        # if the database name is null give error
        if db_name == '':
            show_error_message('Please Enter dataset Name')
        else:
            # disable the button
            self.pushButton.setEnabled(False)
            #replace the space with the underscore
            try:
                db_name = db_name.replace(' ','_')
            except:
                pass
            #create an empty data frame
            meta_data_frame = pd.DataFrame(columns=['field','data_type','unique_data'])
            # fill the data frame from meta data dict
            for key in self.meta_data.keys():
                if self.meta_data[key]['datatype'] == 'CHARACTER':
                    char = ''
                    for d in self.data[key].unique():
                        char+=str(d)
                        char+=','
                    meta_data_frame.loc[len(meta_data_frame)] = [key ,self.meta_data[key]['datatype'],char]
                elif self.meta_data[key]['datatype'] == 'DATE':
                    try:
                        try:
                            self.data[key] = pd.to_datetime(self.data[key], dayfirst=False)
                        except:
                            self.data[key] = pd.to_datetime(self.data[key], dayfirst=False)
                            print(self.data['key'])
                        meta_data_frame.loc[len(meta_data_frame)] = [key ,self.meta_data[key]['datatype'],f'''{str(self.data[key].min()).split(' ')[0]},{str(self.data[key].max()).split(' ')[0]}''']
                    except Exception as e:
                        print(e)
                        print('No time in date')
                        try:
                            self.data[key] = pd.to_datetime(self.data[key], dayfirst=False)
                        except:
                            self.data[key] = pd.to_datetime(self.data[key], dayfirst=False)
                        meta_data_frame.loc[len(meta_data_frame)] = [key ,self.meta_data[key]['datatype'],f'''{self.data[key].min()},{self.data[key].max()}''']

                else:
                    meta_data_frame.loc[len(meta_data_frame)] = [key ,self.meta_data[key]['datatype'],f'''{self.data[key].min()},{self.data[key].max()}''']
            # enforce the datatype of the pandas
            df = enforce_data_types(self.data,self.meta_data)
            try:
                # save the database to the sqlite3
                df.to_sql(db_name,engine,if_exists='replace',index=True,chunksize=500000)
                # save the databasename column in the data frame
                meta_data_frame['dbname']=db_name
                #save the dataset to database
                meta_data_frame.to_sql('meta_data',engine,if_exists='append')
            except Exception as e:
                print(e)
                #show_error_message(str(e))
            self.db_function()
            main_window.close()
            show_success_message('Successfully dataset Loaded.')

    # def csv_to_sqlite(self,df,db_name):
    #     result = []
    #     data = df[:1]
    #     data.to_sql(db_name,engine,if_exists='replace',index=False)
    #     for i in range(len(df)):
    #         result.extend(list(df.loc[i].values))
    #     print(result)
    #     conn = sqlite3.connect("sqlite.db")
    #     c = conn.cursor()
    #     str_1 = ''
    #     for i in range(len(self.data_columns)):
    #         if i == len(self.data_columns) -1:
    #             str_1 += '?'
    #         else:
    #             str_1 += '?,'
    #     # sql_query = 
    #     # print(sql_query)
    #     c.executemany('insert into asd values (?,?,?,?)', result)
    #     conn.commit()
    #     conn.close()

    def fill_table(self):
        '''
            fill the table with data 
        '''
        #get 10 rows of data
        print("all_data",self.data)
        all_data = self.data[:10]
        # set the column count 
        # self.tableWidget.setColumnCount(len(self.data_columns))
        # set row count
        # self.tableWidget.setRowCount(10)
        #set data column labels
        # self.tableWidget.setHorizontalHeaderLabels(self.data.columns)
        # iterate over the data and set it into table
        for key,value in all_data.items():
            for k,val in enumerate(value):
                # self.tableWidget.setItem(k,self.data_columns.index(key),QtWidgets.QTableWidgetItem(str(val)))
        
    def retranslateUi(self, Select):
        _translate = QtCore.QCoreApplication.translate
        Select.setWindowTitle(_translate("Select", "MainWindow"))
        self.label.setText(_translate("Select", "Enter Database name"))
        self.pushButton.setText(_translate("Select", "Save"))
        self.label_2.setText(_translate("Select", "Load Data"))


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    Select = QtWidgets.QMainWindow()
    ui = Ui_Select()
    ui.setupUi(Select)
    Select.show()
    sys.exit(app.exec_())
